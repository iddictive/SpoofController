# Swift & macOS Architectural Rules

## App Packaging & Icons

### [SWIFT-001]: macOS Icon Specification
*   **Инцидент**: Иконки выглядели «раздутыми» в Launchpad из-за отсутствия правильного padding в iOS-ассетах.
*   **Сигнал**: iOS и macOS имеют разные стандарты отступов для иконок 1024x1024.
*   **Выведенное правило**: Для macOS приложений ОБЯЗАТЕЛЬНО использовать холст 1024x1024 с прозрачным отступом (padding). Контентная область должна составлять **80% (824px)** или **90% (924px)** от размера холста. Прямое использование `sips -p` (opaque padding) запрещено.
*   **Метод проверки**: `swift scripts/pad_icon.swift` должен возвращать `Successfully created padded icon`. Проверка наличия прозрачности через `sips -g hasAlpha`.

### [SWIFT-002]: Unified Icon Naming
*   **Инцидент**: Рассинхрон между `Info.plist` и скриптами сборки при смене названия файла иконки.
*   **Сигнал**: Использование разных имен для иконок требует правок в нескольких системных файлах.
*   **Выведенное правило**: Всегда использовать стандартизированное имя `AppIcon.icns` в папке `assets/`. В `Info.plist` ключ `CFBundleIconFile` должен всегда указывать на `AppIcon`.
*   **Метод проверки**: `grep "AppIcon.icns" build.sh` и `grep "<string>AppIcon</string>" Info.plist`.

## Process Lifecycle Management

### [SWIFT-003]: Robust CLI Process Termination
*   **Инцидент**: Бинарник `spoofdpi` продолжал висеть в процессах после закрытия Menu Bar приложения.
*   **Сигнал**: macOS не убивает дочерние CLI процессы автоматически при завершении родительского GUI.
*   **Выведенное правило**: Использовать выделенный `Manager` (например, `SpoofManager`) для управления жизненным циклом бинарников. ОБЯЗАТЕЛЬНО реализовывать `stop()` метод, вызывающий `process.terminate()` и, в случае неудачи, `pkill -f [binary_name]` при деинициализации или выходе из приложения.
*   **Метод проверки**: `pgrep [binary_name]` после закрытия приложения должен возвращать пустой результат.

## Development & Maintenance

### [SWIFT-004]: CI/CD Friendly Packaging
*   **Инцидент**: Скрипты создания DMG, требующие монтирования томов, фейлились в облачном CI (GitHub Actions).
*   **Сигнал**: CI окружения часто имеют ограничения на монтирование устройств.
*   **Выведенное правило**: Для сборки DMG в автоматизированных пайплайнах ОБЯЗАТЕЛЬНО использовать `hdiutil create -srcfolder [path] [output].dmg`. Это не требует монтирования и работает в любых средах.
*   **Метод проверки**: Прогон GitHub Action должен завершаться без ошибок на этапе `Create DMG`.

### [SWIFT-005]: Uninstallation Accessibility
*   **Инцидент**: Пользователи, установившие приложение через DMG, не имеют доступа к скрипту `uninstall.sh`, так как он находится в исходниках.
*   **Сигнал**: Путь к скрипту удаления в README должен быть доступен всем категориям пользователей.
*   **Выведенное правило**: В документации для удаления ОБЯЗАТЕЛЬНО предоставлять `curl | bash` однострочник, ссылающийся на `main` ветку репозитория.
*   **Метод проверки**: Ссылка в README должна вести на `raw.githubusercontent.com/.../uninstall.sh`.

## UI & UX Standards

### [SWIFT-006]: Reliable Markdown Rendering in WKWebView
*   **Инцидент**: Простая замена регулярок во всем тексте `README.md` приводила к превращению документа в «стену текста» без абзацев и переносов строк.
*   **Сигнал**: Без блочного парсинга (заголовки, списки, абзацы) браузерный движок игнорирует переносы строк Markdown, сливая всё в одну строку.
*   **Выведенное правило**: При рендеринге Markdown через `WKWebView` (без внешних библиотек) ОБЯЗАТЕЛЬНО использовать построчный или блочный парсер. Каждая строка должна быть классифицирована (заголовок, список, код-блок) или обернута в тег `<p>`. Инлайновое форматирование (жирный текст, ссылки) должно применяться только ПОСЛЕ определения границ блока.
*   **Метод проверки**: Поиск функции `markdownToHTML` в `main.swift` и проверка наличия цикла по строкам (`components(separatedBy: .newlines)`).
